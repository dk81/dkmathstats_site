---
title: "k-Means Clustering In R"
output: html_document
---

&nbsp;

Hi there. In this page, I play around with data and apply K-Means Clustering. K-Means Clustering is an unsupervised machine learning technique which groups/clusters data points into a specific number of groups. The user of the algorithm specifies the number of groups by setting the K-Value.

In R (RStudio), I load in the `ggplot2` and `faraway` packages.

&nbsp;

```{r}
## R Markdown

# K-Means Clustering work.
# References:
# https://www.r-bloggers.com/k-means-clustering-in-r/
# R Graphics Cookbook
# R Graphics Cookbook By Winston Chang

# https://www.r-bloggers.com/k-means-clustering-in-r/
  
# http://stackoverflow.com/questions/14524818/results-of-k-means-used-in-r
# Datacamp Account Notes

library(faraway)
library(ggplot2)

# Save star data from faraway data to star_data variable:

star_data <- star

# Preview data:

head(star_data)
```

&nbsp;

From the `head()` function of `star_data`, you see that there is an index column which is the same as the row numbers. This column can be removed. 

&nbsp;

```{r}
# Remove first column as it is not needed:

star_data <- star_data[, 2:3]
```

&nbsp;

You can explore the dataset even more with the use of the `summary()` and `str()` functions.

```{r}
# Summary and data structure:

summary(star_data)

str(star_data)
```

&nbsp;

With the use of `ggplot2` graphics, you can generate a nice initial scatterplot to have a sense of what the data is like.

```{r, echo = TRUE, fig.width=4.5, fig.height=4.5} 
# Initial Plot (With Full Labels)

ggplot(star_data, aes(x = temp, y = light)) + geom_point() + 
  labs(x = "\n Log Of Surface Temperature", y = "Log Of Light Intensity \n", 
       title = "Temperature Vs Light Intensity \n For Star Data \n") + 
  theme(plot.title = element_text(hjust = 0.5), 
        axis.title.x = element_text(face="bold", colour = "darkgreen", size = 12),
        axis.title.y = element_text(face="bold", colour = "darkgreen", size = 12),
        legend.title = element_text(face="bold", size = 10))
```

&nbsp;

## K-Means Clustering In R

&nbsp;

Doing K-Means Clustering In R is not too difficult. To do the clustering use the `kemans()` command in R. 

```{r}
# k-Means Clustering In R
  
# Set random seed:

set.seed(20)

star_Cluster <- kmeans(star_data, centers = 2, nstart = 25)
star_Cluster
```

&nbsp;

From the `star_Cluster` output, you can see the centers of each cluster as a co-ordinate. In addition, you can see which points are assigned to each cluster. (The two clusters are 1 and 2.)

In the next pieces of code, I create a new copy of the `star_data` dataset and add the cluster assignments as a new column. This will help with plotting later.

&nbsp;

```{r}
# Create new copy of star_data for kmeans with 2 clusters

star_data_cl2 <- star_data

# Add star_Cluster cluster component as new column to star_data_cl2:

star_data_cl2$clusterType <- as.factor(star_Cluster$cluster)
```

&nbsp;

This `ggplot` code chunk is very similar to the previous one. What is included is `colour = clusterType` in the `aes()` part in `ggplot()`.

&nbsp;

```{r, echo = TRUE, fig.width=4.5, fig.height=4.5} 
# Plot with Two Clusters Indicated By Colours:

ggplot(star_data_cl2, aes(x = temp, y = light, colour = clusterType)) + 
  geom_point() + 
  labs(x = "\n Log Of Surface Temperature", y = "Log Of Light Intensity \n", 
       title = "Temperature Vs Light Intensity For Star Data \n",
       colour = "Cluster Group") +  
  theme(plot.title = element_text(hjust = 0.5), 
        axis.title.x = element_text(face="bold", colour = "darkgreen", size = 12),
        axis.title.y = element_text(face="bold", colour = "darkgreen", size = 12),
        legend.title = element_text(face="bold", size = 10))
```


&nbsp;

You can explore the outputs from the K-Means algorithm in R. Refer to the code with comments below.


```{r}
#----------------------------------------------
## Understanding the outputs of k-means:

# cluster output from star_cluster:

star_Cluster$cluster

# Cluster centres:

star_Cluster$centers

# Size Of Each Cluster:

star_Cluster$size

# Number of Iterations:

star_Cluster$iter

# ifault component:

star_Cluster$ifault

# Within Cluster sum of squares (Sum Of Squares In Each Cluster):

star_Cluster$withinss

# Total Within Sum of Squares (Add Within Cluster SumSquares Together):

star_Cluster$tot.withinss

# Between Clusters Sum Of Squares:

star_Cluster$betweenss

# Total Sum Of Squares = BetweenSumSquares + Total Within SumSquares

star_Cluster$totss
```

&nbsp;


## Scree Plots For Determining The Optimal Number Of Clusters

&nbsp;

A natural question would be how many clusters to choose on the data? What is an objective way of determining the number of clusters? One way is with the us of a visual aid called the scree plot.

To develop a scree plot, a dataset needs to be constructed such that there are a sequence of the number of clusters in one column along with its corresponding total within cluster sum of squares in another column. 

&nbsp;

```{r}
####  Optimal Amount Of Clusters (k):

# Scree Plot For Determining Optimal k Clusters.

total_wsumsq <- rep(0, 8) #Initialize

for (k in 1:8){
  star_kmeans <- kmeans(star_data, centers = k, nstart = 25)
  
  # Scree Plot: use total within cluster sum of squares
  
  total_wsumsq[k] <- star_kmeans$tot.withinss 
}
```

&nbsp;

Generating a scree plot in base R is quite simple. The default `plot()` should do.

&nbsp;

```{r, echo = TRUE, fig.width=4.5, fig.height=4.5} 
## Scree Plot In Base R:

plot(x = 1:8, y = total_wsumsq , xlab = "Number Of Clusters (k)", 
     ylab = "Total Within Sum Of Squares") +
  lines(x = 1:8, y = total_wsumsq)
```

&nbsp;

Generating a scree plot with `ggplot2` graphics requires a little bit more work. Before using the `ggplot()` function and its add-on functions a data frame needs to be constructed.

```{r, echo = TRUE, fig.width=4.5, fig.height=4.5} 
## ggplot2 Version Of Scree Plot:

# Create table

scree_table <- data.frame(cbind(1:8, total_wsumsq))

scree_table 

# Change column names:

colnames(scree_table) <- c("k", "TWSS")

# Scree ggplot plot:
ggplot(scree_table, aes(x = k, y = TWSS)) + geom_point() + geom_line() +
  labs(x = "\n Number Of Clusters (k)", y = "Total Within Sum Of Squares \n", 
       title = "Scree Plot For Star Data \n") + 
  theme(plot.title = element_text(hjust = 0.5), 
        axis.title.x = element_text(face="bold", colour = "darkgreen", size = 12),
        axis.title.y = element_text(face="bold", colour = "darkgreen", size = 12),
        legend.title = element_text(face="bold", size = 10))
```

&nbsp;

When it comes to selecting the optimal number of clusters, look for the "elbow" in the scree plot. From the scree plot, a good choice for k is 3. 

&nbsp;

```{r, echo = TRUE, fig.width=4.5, fig.height=4.5} 
# From scree plot, choose k = 3 as our optimal choice for k:

star_km3 <- kmeans(star_data, centers = 3, nstart = 25)
star_km3

# Create table:

star_km3_cl <- star_data

# Add star_km3 cluster component as new column to star_km3:

star_km3_cl$clusterType <- as.factor(star_km3$cluster)

# Plot with Clusters Indicated By Colours:

ggplot(star_km3_cl, aes(x = temp, y = light, color = clusterType)) + 
  geom_point() + 
  labs(x = "\n Log Of Surface Temperature", y = "Log Of Light Intensity \n", 
       title = "Temperature Vs Light Intensity For Star Data \n",
       colour = "Cluster Group") + 
  theme(plot.title = element_text(hjust = 0.5), 
        axis.title.x = element_text(face="bold", colour = "darkgreen", size = 12),
        axis.title.y = element_text(face="bold", colour = "darkgreen", size = 12),
        legend.title = element_text(face="bold", size = 10))
```

&nbsp;


**Alternate Scree Plots**

&nbsp;


```{r, echo = TRUE, fig.width=4.5, fig.height=4.5} 
### --- An Alternate Scree Plot - One (Proportions):


# Alternate Scree Plot For Determining Optimal k Clusters.

ratio <- rep(0, 8)


for (k in 1:8){
  star_kmeans <- kmeans(star_data, centers = k, nstart = 25)
  
  # Scree Plot use total within cluster sum of squares divided by
  # Total sum of squares as a ratio
  
  ratio[k] <- star_kmeans$tot.withinss / star_kmeans$totss
  
}

# Create table

alt_scree <- data.frame(cbind(1:8, ratio))

alt_scree

# Change column names:

colnames(alt_scree) <- c("k", "Ratio")

# Scree ggplot plot:
ggplot(alt_scree, aes(x = k, y = Ratio)) + geom_point() + geom_line() + 
  labs(x = "\n Number Of Clusters (k)", y = "Within Sum Of Squares / Total Sum Of Squares Ratio \n", 
       title = "Scree Plot For Star Data \n") + 
  theme(plot.title = element_text(hjust = 0.5), 
        axis.title.x = element_text(face="bold", colour = "darkgreen", size = 12),
        axis.title.y = element_text(face="bold", colour = "darkgreen", size = 12),
        legend.title = element_text(face="bold", size = 10))
```

&nbsp;

The second alternate scree plot focuses on total variance which is the between sum of squares divided
by the total sum of squares. Instead of an elbow, look for the part where it goes from steep to flat.

&nbsp;

```{r, echo = TRUE, fig.width=4.5, fig.height=4.5} 
## An Alternate Scree Plot - Two (Total Variance) :

total_var <- rep(0, 8)

for (k in 1:8){
  star_kmeans <- kmeans(star_data, centers = k, nstart = 25)
  
  # Scree Plot with total variance: Between Sum Of Squares / Total_SumSquares
  
  total_var[k] <- round( 100 * star_kmeans$betweenss / star_kmeans$totss, 2)
  
}

# Create table

alt_scree2 <- data.frame(cbind(1:8, total_var))

alt_scree2

# Change column names:

colnames(alt_scree2) <- c("k", "Total_Var")

# Scree ggplot plot:
ggplot(alt_scree2, aes(x = k, y = total_var)) + geom_point() + geom_line() + 
  labs(x = "\n Number Of Clusters (k)", y = "Total Variance (Percent) \n", 
       title = "Determining The Optimal Number Of Clusters \n") + 
  theme(plot.title = element_text(hjust = 0.5), 
        axis.title.x = element_text(face="bold", colour = "darkgreen", size = 12),
        axis.title.y = element_text(face="bold", colour = "darkgreen", size = 12),
        legend.title = element_text(face="bold", size = 10))
```



