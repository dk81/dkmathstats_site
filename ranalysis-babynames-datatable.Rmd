---
title: "Analyzing Big Data & Baby Names In R Using data.table"
output: html_document
---

&nbsp;

<center>![](./images/baby-name.jpg)</center>

&nbsp;

Hello. I have recently been learning and experimenting with the data.table package in the statistical program R. This data.table package is similar to dplyr with data manipulation techniques. Both dplyr and data.table have features which are similar to SQL queries (SELECT, WHERE keywords and so on).

This post will highlight some features from data.table. The dataset being used is an interesting babynames dataset. (Warning: This post is quite long.)

&nbsp;

### <u>Table Of Contents</u>

&nbsp;

* <a href="#data">The babynames Dataset</a>
* <a href="#select">Selecting Data Using data.table</a>
* <a href="#rows">Selecting Rows Using i</a>
* <a href="#columns">Selecting Columns in j</a>
* <a href="#by">The by Keyword</a>
* <a href="#ij">Selecting Data in Rows i and Columns j (And The Most Popular Baby Names)</a>
* <a href="#index">Indexing and Keys</a>
* <a href="#names">Changing Column Names</a>
* <a href="#order">Changing Column Order</a>
* <a href="#remove">Removing Columns</a>
* <a href="#summary">Summary</a>
* <a href="#refs">References</a>


<a name="data"></a>

&nbsp;

### <u>The babynames Dataset</u>

&nbsp;

The large dataset that we will be working with is from the babynames dataset in R. These baby names are from the United States. Information on this dataset can be found here. The babynames package has datasets named applicants, births, babynames and lifetables.

We can import the library and dataset in R as well as import the data.table library into R.

&nbsp;

```{r}
# We will work with the babynames dataset:

# To install use: install.packages("data.table")

library(babynames)

library(data.table)

set.seed(45L)

baby_table <- data.table(babynames)

```

&nbsp;

In the last line, we converted the babynames dataset into a data table and set it to the variable baby_table.

&nbsp;

---

&nbsp;

We check if there is any missing data in the dataset.

&nbsp;

```{r}
## Check for any missing values:

sum(is.na(baby_table))
```

&nbsp;

The output shows that there are no NAs which represent missing values. The babynames dataset is already ready for data analysis.

&nbsp;

```{r}
# Dimensions of dataset: (1.82 million rows with 5 columns)
dim(baby_table)

# Column names of the baby_data:

names(baby_table)
```

&nbsp;

Running `dim(baby_table)` returns the dimension of the dataset which is about 1.825 million rows with 5 columns.

The `names()` function returns the names of the 5 columns. These 5 columns are year, sex, name, n (the counts for the name), prop (proportion or percentage of total population).

&nbsp;

```{r}
str(baby_table)

summary(baby_table)
```

&nbsp;

The `str()` function returns the structure of the dataset and information about the column variables.

From the `summary()` function, we retrieve information such as minimum, maximum, mean, median, etc. for the column variables.

&nbsp;

```{r}
head(baby_table)

tail(baby_table)
```

&nbsp;

The `head()` and `tail()` functions for a dataset returns the first 6 and last 6 (respectively) rows of data. One can use the n = argument to change the number of rows to view. I used `n = 10` here for both `head()` and `tail()` functions.


We see that the names collected were from the years 1880 to 2014.

<a name="select"></a>

&nbsp;

### <u>Selecting Data Using data.table</u>

&nbsp;

The general form for subseting a data table is DT[i, j, by]. This means that we take the data table DT, subset/select rows using "i", then calculate "j" grouped by "by".

If the above sounds confusing, please refer to the examples below.

<a name="rows"></a>

&nbsp;

### <u>Selecting Rows Using i</u>

&nbsp;

To start off, here is an example where we select rows 25 to 29 in two ways.

&nbsp;

```{r}
# Format is data_table[i, j, by]

# Selecting rows referring to i:

# Rows from 25 to 28 

baby_table[25:29, ]

baby_table[25:29]

```

&nbsp;

Here is an example where we select a row with a condition. We choose rows with the name Marissa.

&nbsp;

```{r}
# Select rows with a criteria. Name is Marissa

marissa <- baby_table[name == "Marissa"]

head(marissa, n = 10)
```

&nbsp;

We can also select rows with multiple names as the condition.

```{r}
# Select rows with names of Zach and Penny.

baby_table[name %in% c("Zach", "Penny")]
```

<a name="columns"></a>

&nbsp;

### <u>Selecting Columns in j</u>

&nbsp;

We now select columns from the data table.

In this example, we select the year column from baby_table. (No output shown)

&nbsp;

```
# Selecting columns in j:

# Years column:

years <- baby_table[, year]; 
```

&nbsp;

What if we want to select more than one column. We can certainly do that by using the `.()` in the j column.

&nbsp;

```{r}
# Choosing several columns and omit the proportion column:

no_propor <- baby_table[, .(year, sex, name, n)]

head(no_propor)

dim(no_propor)
```

&nbsp;


Instead of using `.()`, we could use the `list()` function as follows.

&nbsp;

```{r}
# Could also use list() function instead of .():

baby_table[, list(year, sex, name, n)]
```

&nbsp;

```{r}
# Note that .() is needed to output a data.table object, otherwise we get a vector.

# We can compute on several columns.

counts <- baby_table[, .(Total_Count = sum(n), Standard_Deviation_Counts = sd(n))]

counts
```

&nbsp;

Note that if we do not use `.()` or `list()` in j we would not return a data.table object. We would instead get a vector and an undesirable output.

We can also run a few calculations to retrieve counts, means (average), standard deviations and such.

<a name="by"></a>

&nbsp;

---

### <u>The by Keyword</u>

&nbsp;

In the previous example, we found the sum of n as the counts and the standard deviations of the counts. The results we found for both male and female genders.

What if we want to find counts, averages and such grouped by gender for example? We use the by keyword.

The example below counts the number of rows for each gender. Note that .N counts the number of rows.

&nbsp;

```{r}
# Using the by:

# Calculating the number of rows for each group in sex column: (.N for counting)

gender_count <- baby_table[, .N, by = sex]

gender_count
```

&nbsp;

The counts above were the number of rows for each gender. But each row has an n value of the counts per row. We have to sum these n values for each gender to retrieve the true counts for each gender.

```{r}
# Calculating the total number of males and females:

gender <- baby_table[, .(Total.Gender = sum(n)), by = sex]

gender
```

&nbsp;

We now check if the female total counts and the male total counts match the total counts from the last example in the previous section.

&nbsp;

```{r}
# Check if the gender counts for male and female equals total counts
# (Is 337135426 = 167070477 + 170064949?)

counts[, Total_Count] == (sum(gender[, Total.Gender]))

```

<a name="ij"></a>


&nbsp;

### <u>Selecting Data in Rows i and Columns j</u>

&nbsp;

We can now select data from rows i and columns j in the data table. The examples below are neat examples as we investigate the popular baby names.

&nbsp;

**The 15 Most Popular Baby Names**

&nbsp;

We find out the 15 most popular baby names (Male and female) from the dataset.

&nbsp;

```{r}
# Combine i and j. Most popular baby names in dataset.

baby_table <- data.table(babynames)

aggregate <- baby_table[, .(Name.Count = sum(n)), by = name][order(-Name.Count)]

head(aggregate, n = 15)
```

&nbsp;

We see that the name James is the most popular baby name from the dataset

Notice that the by keyword was used and that a the sum function was used to create a new variable Name.Count. In addition, we used chaining with the order command. Instead of having

&nbsp;

```
# Long way:

aggregate <- baby_table[, .(Name.Count = sum(n)), by = name]
aggregate <- aggregate[order(-Name.Count)]
```

&nbsp;

you can use chaining to do in one line as illustrated in the image above.

&nbsp;

```
aggregate <- baby_table[, .(Name.Count = sum(n)), by = name][order(-Name.Count)]
```

&nbsp;

---

&nbsp;

**The 15 Most Popular Male Baby Names**

&nbsp;

Now we look at the 15 most popular male baby names.

&nbsp;

```{r}
agg_male <- baby_table[sex == "M", .(Name.Count = sum(n)), by = name][order(-Name.Count)]

head(agg_male, n = 15)
```

&nbsp;

We see that the 5 most popular male baby names are James, John, Robert, Michael and William.

---

**The 15 Most Popular Female Baby Names**

We now present the 15 most popular female baby names.

&nbsp;

```{r}
agg_female <- baby_table[sex == "F", .(Name.Count = sum(n)), by = name][order(-Name.Count)]

head(agg_female, n = 15)
```

&nbsp;

The top five female baby names from the dataset are Mary, Elizabeth, Patricia, Jennifer and Linda.

<a name="index"></a>

&nbsp;

---

### <u>Indexing and Keys</u>

&nbsp;

We can also subset and select data using keys.

To start off, we create a new copy of the babynames dataset and name it key_table. The `setkey()` function takes a data table and a column(s) as reference. In the code below, we put the name column in `setkey()`. When I input key_table["Mario"], "Mario" would refer to the "Mario" in the name column of key_table and all rows containing the name "Mario" would be shown.

&nbsp;

```{r}
# Indexing and keys:

key_table <- data.table(babynames)

# Set key on our data table with column name:
setkey(key_table, name)

# name is keyed column, search for rows with name = "Mario"

key_table["Mario"]
```

&nbsp;

The next example is about selecting multiple names in `setkey()`.

&nbsp;

```{r}
# name is the keyed column
# search for all rows where name is Mario or Dennis:
key_table[c("Mario", "Dennis")]

```
&nbsp;

---


**The nomatch argument**

&nbsp;

The nomatch argument is for cases where a specified value in the row
does not match in the data table rows. If I search for the name "What" alongside with "April" without the nomatch argument I will get NAs (missing values).

&nbsp;

```{r}
# nomatch argument for the case where a value in the row does not match the data table rows
# By default it is NA, nomatch = 0 means no rows to be returned if no matches

key_table[c("April", "What")]

```

&nbsp;

By default, the nomatch argument is set to NA as follows.

&nbsp;

```{r}

key_table[c("April", "What"), nomatch = NA]

```

&nbsp;

Setting nomatch to 0 will omit the row(s) which are not a match.

&nbsp;

```{r}

key_table[c("April", "What"), nomatch = 0]

```

&nbsp;

---

**Counting Methods**

&nbsp;

Using the keys we can also get counts. The two examples show counting where one is aggregated and the other one is separated.

&nbsp;

```{r}
# Counting Methods:
# Counting the number of Marios and Marias (together):

key_table[c("Mario", "Maria"), sum(n)]

# Counting the number of Marios and Marias separately:

key_table[c("Mario", "Maria"), sum(n), by = .EACHI]

```

&nbsp;

---

**Selecting Multiple Columns in Keys**

&nbsp;

Earlier, we set the name column in the `setkey()` function. We can also put multiple columns into `setkey()`. Here are some examples.

&nbsp;

```{r}
## Selecting multiple columns in keys:

# Select year and name columns as keys, sort by year then name:

key_table <- data.table(babynames)

setkey(key_table, year, name)

# Search for the year 2000 with name Sophie:

key_table[.(2000, "Sophie")]

# Search for years 2000, 2001 with names Caitlin and Raj:

key_table[.(c(2000, 2001), c("Caitlin", "Raj"))]

```


<a name="names"></a>

&nbsp;

---

### <u>Changing Column Names</u>

&nbsp;

There are times when column names could use improvements. For example, the column n is understood by mostly math, stats and computer science type people but it is better to replace n with Count (or something similar).

&nbsp;

```{r}
# Changing column names (from "n" to "Count"):

new_col <- data.table(babynames)

new_col <- setnames(new_col, "n", "Count")

head(new_col, n = 10)
```

<a name="order"></a>

&nbsp;

---

### <u>Changing Column Order</u>

&nbsp;

In the original babynames dataset we had "year", "sex", "name", "n", "prop". Here, we want to but the name before sex. We can also change the order of the columns as follows.

```{r}
# Change column order:

ordered <- data.table(babynames)

new_order <- c("year", "name", "sex", "n", "prop")

setcolorder(ordered, new_order)

head(ordered, n = 10)
```

<a name="remove"></a>

&nbsp;

---

### <u>Removing Columns</u>

&nbsp;

In data.table we can also remove columns. One should be careful when removing columns. It is like chopping a carrot; once it is cut you can't put it back together.

Here is the case with removing one column.

&nbsp;

```{r}
# Remove a column:

no_years <- data.table(babynames)

no_years <- no_years[, year := NULL];

head(no_years);
```

&nbsp;


We can also remove multiple columns. Here, we remove the year, sex and prop columns leaving us with the name and n columns.

&nbsp;

```{r}
# Remove year, sex and prop columns but keep the name and n columns:

just_names <- data.table(babynames) # Create new copy.

just_names <- just_names[, c("year", "sex", "prop") := NULL];

head(just_names, n = 20)
```

<a name="summary"></a>

&nbsp;

### <u>Summary</u>

&nbsp;

Well, that was a lot to digest and take in. In short, the data.table package in R allows for data selection, data extraction and data manipulation of (large) data sets. Since computing power has increased tremendously over the years, it is easier and faster to analyze big data.

We have also learned some neat things from the babynames dataset which is close to 2 million rows and 5 columns. From 1880 to 2014, the most popular male name is James and the most popular female name is Mary. Overall the most popular names (1880 to 2014) are James, John, Robert, Michael and Mary.

In the US, there are more babies named Maria (Count: 538815) than Mario (Count: 141494) from 1880 to 2014.

It is unknown whether name variations such as Rob for Robert and Bill for William are counted as the same or not. One could use these baby names statistics to predict the most popular baby name (male and female) for 2016, 2017 , and so forth. Predictions can be made using this entire dataset or the most recent years (2004 to 2014) in the dataset for example.

More can done with this dataset such as look at the years from 2000 to 2014 for example.

<a name="refs"></a>

&nbsp;

### <u>References</u>

&nbsp;

The babynames dataset documentation: https://cran.r-project.org/web/packages/babynames/babynames.pdf

This cheat sheet for data.table has been really useful.

https://s3.amazonaws.com/assets.datacamp.com/img/blog/data+table+cheat+sheet.pdf

The interesting featured image is from http://parentingatoz.com/wp-content/uploads/2015/09/baby-name.jpg